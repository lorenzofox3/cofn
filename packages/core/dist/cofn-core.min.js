const t=Object.freeze({observedAttributes:[],Klass:HTMLElement}),e=(e,n=t)=>{const{observedAttributes:o=[],Klass:r=HTMLElement,shadow:i}=n;return class extends r{#t;#e;#s=[];static get observedAttributes(){return[...o]}constructor(){super(),this.#e=new AbortController;const t=this,s=void 0!==i?t.attachShadow(i):t;this.#t=e.bind(this)({$host:t,$root:s,$signal:this.#e.signal}),this.render=this.render.bind(this),this.#t.next()}connectedCallback(){this.render()}disconnectedCallback(){window.queueMicrotask((()=>{!1===this.isConnected&&(this.#e.abort(),this.#t.return())}))}attributeChangedCallback(t,e,s){e!==s&&this.isConnected&&this.render()}render(t={}){const e=this.#s.length;this.#s.push(t),e||window.queueMicrotask((()=>{const t={attributes:s(this),...Object.assign(...this.#s)};this.hasAttribute("debug")&&console.debug("rendering",t),this.#t.next(t),this.#s.length=0}))}}},s=t=>Object.fromEntries(t.getAttributeNames().map((e=>[e,t.getAttribute(e)]))),n=(t,s,n={})=>{customElements.get(t)||customElements.define(t,e(s,{observedAttributes:n.observedAttributes,Klass:o[n?.extends]??HTMLElement,...n}),n)},o={label:HTMLLabelElement,button:HTMLButtonElement,form:HTMLFormElement,li:HTMLLIElement,ul:HTMLUListElement,input:HTMLInputElement,p:HTMLParagraphElement,a:HTMLAnchorElement,body:HTMLBodyElement};export{e as component,n as define};
